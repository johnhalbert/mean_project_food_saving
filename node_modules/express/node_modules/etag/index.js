/*!
 * etag
<<<<<<< HEAD
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
=======
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */

'use strict'

/**
 * Module exports.
 * @public
>>>>>>> b54e1981eb56a6b330fbeb153848a4b67979d08e
 */

module.exports = etag

/**
 * Module dependencies.
<<<<<<< HEAD
 */

var crc = require('crc').crc32
=======
 * @private
 */

>>>>>>> b54e1981eb56a6b330fbeb153848a4b67979d08e
var crypto = require('crypto')
var Stats = require('fs').Stats

/**
 * Module variables.
<<<<<<< HEAD
 */

var crc32threshold = 1000 // 1KB
var NULL = new Buffer([0])
var toString = Object.prototype.toString

/**
=======
 * @private
 */

var base64PadCharRegExp = /=+$/
var toString = Object.prototype.toString

/**
 * Generate an entity tag.
 *
 * @param {Buffer|string} entity
 * @return {string}
 * @private
 */

function entitytag(entity) {
  if (entity.length === 0) {
    // fast-path empty
    return '"0-1B2M2Y8AsgTpgAmY7PhCfg"'
  }

  // compute hash of entity
  var hash = crypto
    .createHash('md5')
    .update(entity, 'utf8')
    .digest('base64')
    .replace(base64PadCharRegExp, '')

  // compute length of entity
  var len = typeof entity === 'string'
    ? Buffer.byteLength(entity, 'utf8')
    : entity.length

  return '"' + len.toString(16) + '-' + hash + '"'
}

/**
>>>>>>> b54e1981eb56a6b330fbeb153848a4b67979d08e
 * Create a simple ETag.
 *
 * @param {string|Buffer|Stats} entity
 * @param {object} [options]
 * @param {boolean} [options.weak]
 * @return {String}
<<<<<<< HEAD
 * @api public
=======
 * @public
>>>>>>> b54e1981eb56a6b330fbeb153848a4b67979d08e
 */

function etag(entity, options) {
  if (entity == null) {
    throw new TypeError('argument entity is required')
  }

<<<<<<< HEAD
=======
  // support fs.Stats object
>>>>>>> b54e1981eb56a6b330fbeb153848a4b67979d08e
  var isStats = isstats(entity)
  var weak = options && typeof options.weak === 'boolean'
    ? options.weak
    : isStats

<<<<<<< HEAD
  // support fs.Stats object
  if (isStats) {
    return stattag(entity, weak)
  }

  if (typeof entity !== 'string' && !Buffer.isBuffer(entity)) {
    throw new TypeError('argument entity must be string, Buffer, or fs.Stats')
  }

  var hash = weak
    ? weakhash(entity)
    : stronghash(entity)

  return weak
    ? 'W/"' + hash + '"'
    : '"' + hash + '"'
=======
  // validate argument
  if (!isStats && typeof entity !== 'string' && !Buffer.isBuffer(entity)) {
    throw new TypeError('argument entity must be string, Buffer, or fs.Stats')
  }

  // generate entity tag
  var tag = isStats
    ? stattag(entity)
    : entitytag(entity)

  return weak
    ? 'W/' + tag
    : tag
>>>>>>> b54e1981eb56a6b330fbeb153848a4b67979d08e
}

/**
 * Determine if object is a Stats object.
 *
 * @param {object} obj
 * @return {boolean}
 * @api private
 */

function isstats(obj) {
<<<<<<< HEAD
  // not even an object
  if (obj === null || typeof obj !== 'object') {
    return false
  }

  // genuine fs.Stats
  if (obj instanceof Stats) {
=======
  // genuine fs.Stats
  if (typeof Stats === 'function' && obj instanceof Stats) {
>>>>>>> b54e1981eb56a6b330fbeb153848a4b67979d08e
    return true
  }

  // quack quack
<<<<<<< HEAD
  return 'atime' in obj && toString.call(obj.atime) === '[object Date]'
=======
  return obj && typeof obj === 'object'
>>>>>>> b54e1981eb56a6b330fbeb153848a4b67979d08e
    && 'ctime' in obj && toString.call(obj.ctime) === '[object Date]'
    && 'mtime' in obj && toString.call(obj.mtime) === '[object Date]'
    && 'ino' in obj && typeof obj.ino === 'number'
    && 'size' in obj && typeof obj.size === 'number'
}

/**
 * Generate a tag for a stat.
 *
<<<<<<< HEAD
 * @param {Buffer} entity
 * @return {String}
 * @api private
 */

function stattag(stat, weak) {
  var mtime = stat.mtime.toISOString()
  var size = stat.size.toString(16)

  if (weak) {
    return 'W/"' + size + '-' + crc(mtime) + '"'
  }

  var hash = crypto
    .createHash('md5')
    .update('file', 'utf8')
    .update(NULL)
    .update(size, 'utf8')
    .update(NULL)
    .update(mtime, 'utf8')
    .digest('base64')

  return '"' + hash + '"'
}

/**
 * Generate a strong hash.
 *
 * @param {Buffer} entity
 * @return {String}
 * @api private
 */

function stronghash(entity) {
  if (entity.length === 0) {
    // fast-path empty
    return '1B2M2Y8AsgTpgAmY7PhCfg=='
  }

  return crypto
    .createHash('md5')
    .update(entity, 'utf8')
    .digest('base64')
}

/**
 * Generate a weak hash.
 *
 * @param {Buffer} entity
 * @return {String}
 * @api private
 */

function weakhash(entity) {
  if (entity.length === 0) {
    // fast-path empty
    return '0-0'
  }

  var len = typeof entity === 'string'
    ? Buffer.byteLength(entity, 'utf8')
    : entity.length

  if (len <= crc32threshold) {
    // crc32 plus length when it's fast
    // crc(str) only accepts utf-8 encoding
    return len.toString(16) + '-' + crc(entity).toString(16)
  }

  // use md4 for long strings
  return crypto
    .createHash('md4')
    .update(entity, 'utf8')
    .digest('base64')
=======
 * @param {object} stat
 * @return {string}
 * @private
 */

function stattag(stat) {
  var mtime = stat.mtime.getTime().toString(16)
  var size = stat.size.toString(16)

  return '"' + size + '-' + mtime + '"'
>>>>>>> b54e1981eb56a6b330fbeb153848a4b67979d08e
}
